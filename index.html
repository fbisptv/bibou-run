<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#2c3e50">
    <title>Super Bibou Run</title>
    
    <!-- Configuration PWA pour iOS et Android -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="BibouRun">
    <link rel="manifest" href="data:application/manifest+json;base64,ewogICJuYW1lIjogIlN1cGVyIEJpYm91IFJ1biIsCiAgInNob3J0X25hbWUiOiAiQmlib3VSdW4iLAogICJzdGFydF91cmwiOiAiLiIsCiAgImRpc3BsYXkiOiAiZnVsbHNjcmVlbiIsCiAgImJhY2tncm91bmRfY29xvciI6ICIjMmMzZTUwIiwKICAidGhlbWVfY29sb3IiOiAiIzJjM2U1MCIKfQ==">
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #87CEEB; /* Ciel bleu */
            touch-action: none; /* Empêche le zoom/scroll du navigateur */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        #score-board {
            font-size: 24px;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            pointer-events: auto;
            border: 2px solid white;
        }
        button {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 18px;
            border-radius: 5px;
            margin-top: 10px;
            cursor: pointer;
        }
        #controls-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.7);
            font-size: 14px;
            pointer-events: none;
            text-shadow: 1px 1px 0 #000;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="score-board">Pièces: 0 | Vies: 3</div>
        <div id="controls-hint">Glisse pour courir • Tapote pour sauter</div>
    </div>

    <div id="message-box">
        <h2 id="msg-title">Titre</h2>
        <p id="msg-text">Texte</p>
        <button onclick="startGame()">Rejouer</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * JEU PWA - SUPER BIBOU RUN
 * Optimisé pour mobile et tactile
 */

// --- Configuration ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

// États du jeu
let gameState = 'playing'; // playing, gameover, win
let coins = 0;
let lives = 3;
let cameraX = 0;
let animationFrameId;

// Physique
const GRAVITY = 0.6;
const FRICTION = 0.8;
const MOVE_SPEED = 0.5; // Accélération
const MAX_SPEED = 6;
const JUMP_FORCE = -13;

// Inputs
let touchStartX = 0;
let isTouchingMove = false;
let moveFingerId = null;
let inputX = 0; // -1 (gauche), 0 (stop), 1 (droite)

// Le Monde
const TILE_SIZE = 50;
const LEVEL_LENGTH = 150; // Nombre de tuiles de long
let platforms = [];
let spikes = [];
let collectibles = [];
let flag = null;
let particles = [];

// Le Joueur
const player = {
    x: 100,
    y: 100,
    w: 30, // Largeur hitbox
    h: 50, // Hauteur hitbox
    vx: 0,
    vy: 0,
    color: '#e74c3c', // Rouge LHC
    grounded: false,
    facingRight: true,
    animTimer: 0
};

// --- Initialisation ---

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function initLevel() {
    platforms = [];
    spikes = [];
    collectibles = [];
    particles = [];
    
    // Sol de départ
    for(let i=0; i<10; i++) {
        platforms.push({x: i*TILE_SIZE, y: height - TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE});
    }

    // Génération procédurale du niveau
    let currentX = 10 * TILE_SIZE;
    let currentY = height - TILE_SIZE;

    for(let i=10; i < LEVEL_LENGTH; i++) {
        // Aléatoire : trou, plateforme normale, ou plateforme haute
        let rand = Math.random();
        
        if (rand < 0.1) {
            // Trou (rien)
            currentX += TILE_SIZE;
        } else if (rand < 0.3) {
            // Plateforme plus haute ou plus basse
            let heightChange = (Math.floor(Math.random() * 3) - 1) * TILE_SIZE;
            currentY += heightChange;
            // Garde-fou limites écran
            if(currentY > height - TILE_SIZE) currentY = height - TILE_SIZE;
            if(currentY < height - 200) currentY = height - 200;
            
            platforms.push({x: currentX, y: currentY, w: TILE_SIZE, h: TILE_SIZE});
            
            // Peut-être un pic ?
            if(Math.random() < 0.3) {
                spikes.push({x: currentX + 10, y: currentY - 20, w: 30, h: 20});
            }
             currentX += TILE_SIZE;
        } else {
            // Sol normal
            platforms.push({x: currentX, y: currentY, w: TILE_SIZE, h: TILE_SIZE});
            
            // Peut-être une pièce ?
            if(Math.random() < 0.2) {
                collectibles.push({
                    x: currentX + TILE_SIZE/2, 
                    y: currentY - 60, 
                    r: 10, 
                    active: true,
                    floatOffset: Math.random() * Math.PI
                });
            }
            currentX += TILE_SIZE;
        }
    }

    // Drapeau d'arrivée
    flag = { x: currentX, y: currentY - 100 };
    // Plateforme sous le drapeau pour être sûr
    platforms.push({x: currentX, y: currentY, w: TILE_SIZE*3, h: TILE_SIZE});
}

function startGame() {
    gameState = 'playing';
    player.x = 100;
    player.y = 100;
    player.vx = 0;
    player.vy = 0;
    cameraX = 0;
    lives = 3;
    coins = 0;
    document.getElementById('message-box').style.display = 'none';
    initLevel();
    updateUI();
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    loop();
}

// --- Gestion des Contrôles Tactiles ---

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        
        // Si aucun doigt ne bouge le perso, celui-ci devient le doigt de mouvement
        if (!isTouchingMove) {
            isTouchingMove = true;
            moveFingerId = t.identifier;
            touchStartX = t.clientX;
        } else {
            // Sinon, c'est un saut !
            if (player.grounded) {
                player.vy = JUMP_FORCE;
                player.grounded = false;
                createParticles(player.x + player.w/2, player.y + player.h, 5, '#fff');
            }
        }
    }
}, {passive: false});

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        if (t.identifier === moveFingerId) {
            let delta = t.clientX - touchStartX;
            // Zone morte de 10px
            if (delta > 20) inputX = 1;
            else if (delta < -20) inputX = -1;
            else inputX = 0;
            
            // Mise à jour du point de référence pour que ça suive le doigt
            // (Optionnel: style joystick virtuel invisible)
            if (Math.abs(delta) > 50) {
               touchStartX = t.clientX - (50 * Math.sign(delta));
            }
        }
    }
}, {passive: false});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        if (t.identifier === moveFingerId) {
            isTouchingMove = false;
            moveFingerId = null;
            inputX = 0;
        }
    }
});

// Support clavier pour test sur PC
window.addEventListener('keydown', (e) => {
    if(e.code === 'ArrowRight') inputX = 1;
    if(e.code === 'ArrowLeft') inputX = -1;
    if(e.code === 'Space' && player.grounded) {
        player.vy = JUMP_FORCE;
        player.grounded = false;
    }
});
window.addEventListener('keyup', (e) => {
    if(e.code === 'ArrowRight' || e.code === 'ArrowLeft') inputX = 0;
});

// --- Moteur de Jeu ---

function update() {
    if (gameState !== 'playing') return;

    // Mouvement X
    if (inputX !== 0) {
        player.vx += inputX * MOVE_SPEED;
        player.facingRight = inputX > 0;
        player.animTimer += 0.2;
    } else {
        player.vx *= FRICTION;
        player.animTimer = 0;
    }

    // Clamp vitesse
    if (player.vx > MAX_SPEED) player.vx = MAX_SPEED;
    if (player.vx < -MAX_SPEED) player.vx = -MAX_SPEED;

    // Mouvement Y
    player.vy += GRAVITY;
    
    // Application
    player.x += player.vx;
    player.y += player.vy;

    // Collisions Plateformes
    player.grounded = false;
    for (let p of platforms) {
        if (checkRectCollide(player.x, player.y, player.w, player.h, p.x, p.y, p.w, p.h)) {
            // Collision bas
            if (player.vy > 0 && player.y + player.h - player.vy <= p.y) {
                player.y = p.y - player.h;
                player.vy = 0;
                player.grounded = true;
            }
            // Collision haut
            else if (player.vy < 0 && player.y - player.vy >= p.y + p.h) {
                player.y = p.y + p.h;
                player.vy = 0;
            }
            // Collision cotés
            else if (player.vx > 0 && player.x + player.w - player.vx <= p.x) {
                player.x = p.x - player.w;
                player.vx = 0;
            }
            else if (player.vx < 0 && player.x - player.vx >= p.x + p.w) {
                player.x = p.x + p.w;
                player.vx = 0;
            }
        }
    }

    // Collisions Pics
    for (let s of spikes) {
        if (checkRectCollide(player.x, player.y, player.w, player.h, s.x, s.y, s.w, s.h)) {
            hurtPlayer();
        }
    }

    // Collisions Pièces
    for (let c of collectibles) {
        if (c.active && checkDistance(player.x + player.w/2, player.y + player.h/2, c.x, c.y, player.w/2 + c.r)) {
            c.active = false;
            coins++;
            updateUI();
            createParticles(c.x, c.y, 10, '#f1c40f');
        }
        // Animation pièce
        c.floatOffset += 0.1;
    }

    // Victoire ?
    if (player.x > flag.x) {
        endGame(true);
    }

    // Mort par chute
    if (player.y > height + 200) {
        hurtPlayer();
    }

    // Caméra
    // La caméra suit le joueur mais est lissée
    let targetCamX = player.x - width * 0.3;
    if (targetCamX < 0) targetCamX = 0;
    cameraX += (targetCamX - cameraX) * 0.1;

    // Particules
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if(p.life <= 0) particles.splice(i, 1);
    }
}

function hurtPlayer() {
    lives--;
    updateUI();
    createParticles(player.x + player.w/2, player.y + player.h/2, 20, '#e74c3c');
    
    if (lives <= 0) {
        endGame(false);
    } else {
        // Respawn un peu en arrière
        player.y = 0; 
        player.x -= 200;
        if(player.x < 100) player.x = 100;
        player.vx = 0;
        player.vy = 0;
    }
}

function endGame(win) {
    gameState = win ? 'win' : 'gameover';
    const box = document.getElementById('message-box');
    const title = document.getElementById('msg-title');
    const txt = document.getElementById('msg-text');
    
    box.style.display = 'block';
    if (win) {
        title.innerText = "VICTOIRE !";
        title.style.color = "#2ecc71";
        txt.innerText = `Bravo Tintin ! Tu as récupéré ${coins} pièces.`;
    } else {
        title.innerText = "PERDU...";
        title.style.color = "#e74c3c";
        txt.innerText = "Pas de panique, réessaie !";
    }
}

function createParticles(x, y, count, color) {
    for(let i=0; i<count; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            life: 30 + Math.random() * 20,
            color: color
        });
    }
}

function updateUI() {
    document.getElementById('score-board').innerHTML = `Pièces: ${coins} | Vies: ${lives}`;
}

// --- Rendu ---

function draw() {
    // Effacer l'écran
    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, width, height);

    ctx.save();
    // Appliquer la caméra
    ctx.translate(-cameraX, 0);

    // Dessiner le décor de fond (Parallax simple)
    ctx.fillStyle = '#6ab0cf';
    ctx.beginPath();
    ctx.arc(cameraX + width - 100, 100, 50, 0, Math.PI*2); // Soleil/Lune
    ctx.fill();

    // Plateformes
    ctx.fillStyle = '#27ae60'; // Herbe
    ctx.strokeStyle = '#2c3e50';
    ctx.lineWidth = 2;
    for (let p of platforms) {
        // Optimisation: ne dessiner que ce qui est à l'écran
        if(p.x + p.w > cameraX && p.x < cameraX + width) {
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.strokeRect(p.x, p.y, p.w, p.h);
            // Détail herbe
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(p.x, p.y, p.w, 10);
            ctx.fillStyle = '#27ae60';
        }
    }

    // Pics
    ctx.fillStyle = '#c0392b';
    for (let s of spikes) {
        if(s.x + s.w > cameraX && s.x < cameraX + width) {
            ctx.beginPath();
            ctx.moveTo(s.x, s.y + s.h);
            ctx.lineTo(s.x + s.w/2, s.y);
            ctx.lineTo(s.x + s.w, s.y + s.h);
            ctx.fill();
        }
    }

    // Pièces
    ctx.fillStyle = '#f1c40f';
    ctx.strokeStyle = '#f39c12';
    for (let c of collectibles) {
        if(c.active && c.x + c.r > cameraX && c.x - c.r < cameraX + width) {
            let floatY = Math.sin(c.floatOffset) * 5;
            ctx.beginPath();
            ctx.arc(c.x, c.y + floatY, c.r, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
            // Reflet
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.beginPath();
            ctx.arc(c.x - 3, c.y + floatY - 3, 3, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#f1c40f';
        }
    }

    // Drapeau
    ctx.fillStyle = '#ecf0f1'; // Mat
    ctx.fillRect(flag.x, flag.y, 5, 100);
    ctx.fillStyle = '#e74c3c'; // Drapeau
    ctx.beginPath();
    ctx.moveTo(flag.x + 5, flag.y);
    ctx.lineTo(flag.x + 60, flag.y + 20);
    ctx.lineTo(flag.x + 5, flag.y + 40);
    ctx.fill();

    // Particules
    for (let p of particles) {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 4, 4);
    }

    // --- Dessin du Joueur (Super Bibou) ---
    drawPlayer();

    ctx.restore();
}

function drawPlayer() {
    let px = player.x;
    let py = player.y;
    let pw = player.w;
    let ph = player.h;

    // Calcul animation marche
    let legOffset = 0;
    let armOffset = 0;
    if (Math.abs(player.vx) > 0.1 && !player.grounded) {
        // Saut pose
        legOffset = Math.PI / 4; 
    } else if (Math.abs(player.vx) > 0.1) {
        // Marche
        legOffset = Math.sin(player.animTimer) * 0.5;
        armOffset = Math.cos(player.animTimer) * 0.5;
    }

    ctx.save();
    ctx.translate(px + pw/2, py + ph/2);
    if (!player.facingRight) ctx.scale(-1, 1);

    // Corps
    ctx.fillStyle = '#3498db'; // Bleu
    ctx.fillRect(-10, -15, 20, 30);

    // Tête
    ctx.fillStyle = '#f1c40f'; // Peau
    ctx.beginPath();
    ctx.arc(0, -25, 12, 0, Math.PI*2);
    ctx.fill();
    
    // Casquette Rouge (style Mario/LHC)
    ctx.fillStyle = '#e74c3c';
    ctx.fillRect(-12, -32, 24, 8);
    ctx.fillRect(0, -32, 20, 8); // Visière

    // Yeux
    ctx.fillStyle = 'black';
    ctx.fillRect(4, -28, 2, 2);

    // Jambes
    ctx.strokeStyle = '#2c3e50';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    
    // Jambe gauche
    ctx.beginPath();
    ctx.moveTo(-5, 15);
    ctx.lineTo(-5 - Math.sin(legOffset)*10, 25);
    ctx.stroke();
    
    // Jambe droite
    ctx.beginPath();
    ctx.moveTo(5, 15);
    ctx.lineTo(5 + Math.sin(legOffset)*10, 25);
    ctx.stroke();

    // Bras
    ctx.beginPath();
    ctx.moveTo(0, -5);
    ctx.lineTo(Math.sin(armOffset)*10, 5);
    ctx.stroke();

    // Echarpe (pour le style)
    ctx.fillStyle = 'white';
    ctx.fillRect(-8, -12, 16, 4);
    ctx.fillStyle = 'red';
    ctx.fillRect(-2, -12, 10, 4); // Le bout qui vole

    ctx.restore();
}

// Utilitaires de collision
function checkRectCollide(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
}
function checkDistance(x1, y1, x2, y2, r) {
    let a = x1 - x2;
    let b = y1 - y2;
    return Math.sqrt(a*a + b*b) < r;
}

// Boucle principale
function loop() {
    update();
    draw();
    animationFrameId = requestAnimationFrame(loop);
}

// Démarrage
startGame();

</script>
</body>
</html>

