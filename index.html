<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#0d0d15">
    <title>Cyber Bibou 2077 v3.2</title>
    
    <!-- PWA Config -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
            background-color: #0d0d15; touch-action: none; font-family: 'Orbitron', sans-serif;
            user-select: none; -webkit-user-select: none;
        }
        canvas { display: block; width: 100%; height: 100%; }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; z-index: 10;
        }
        .top-hud { display: flex; justify-content: space-between; width: 100%; align-items: center; }
        .hud-text { color: #0ff; font-size: 20px; text-shadow: 0 0 10px #0ff; font-weight: bold; letter-spacing: 2px; }
        #lives-display { color: #ff3333; text-shadow: 0 0 10px #ff3333; font-size: 24px; }
        #level-indicator { color: #f0f; text-shadow: 0 0 10px #f0f; }
        #powerup-container { position: absolute; top: 60px; left: 20px; display: flex; flex-direction: column; gap: 5px; }
        .powerup-tag { color: #fff; font-size: 14px; display: none; font-weight: bold; }
        #message-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(13, 13, 21, 0.95); color: white; padding: 40px;
            border-radius: 10px; text-align: center; display: none; pointer-events: auto;
            border: 2px solid #0ff; box-shadow: 0 0 20px #0ff; z-index: 20; min-width: 320px;
        }
        button {
            background: transparent; color: #0ff; border: 2px solid #0ff; padding: 15px 30px;
            font-size: 20px; margin-top: 20px; cursor: pointer; font-family: 'Orbitron', sans-serif;
            text-transform: uppercase; box-shadow: 0 0 10px #0ff; transition: all 0.2s;
        }
        button:active { background: #0ff; color: #000; box-shadow: 0 0 20px #0ff; }
        #controls-hint {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.5); font-size: 14px; pointer-events: none;
        }
        #rotate-screen {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #0d0d15; z-index: 9999; flex-direction: column; align-items: center;
            justify-content: center; color: #0ff; text-align: center; font-family: 'Orbitron', sans-serif;
        }
        @media screen and (orientation: portrait) { #rotate-screen { display: flex; } }
    </style>
</head>
<body>

    <div id="rotate-screen">
        <div style="font-size: 60px; margin-bottom:20px;">‚ö†Ô∏è</div>
        <h2>SYST√àME EN PAUSE</h2>
        <p>Tourne ton terminal en mode paysage<br>pour activer le protocole Cyber-Bibou.</p>
    </div>

    <div id="ui-layer">
        <div class="top-hud">
            <div class="hud-text" id="score-board">CREDITS: 0</div>
            <div class="hud-text" id="lives-display">‚ù§‚ù§‚ù§</div>
            <div class="hud-text" id="level-indicator">NIVEAU 1</div>
        </div>
        <div id="powerup-container">
            <div id="status-shield" class="powerup-tag" style="color:#0f0;">üõ°Ô∏è BOUCLIER</div>
            <div id="status-magnet" class="powerup-tag" style="color:#a0f;">üß≤ AIMANT</div>
        </div>
        <div id="controls-hint">GAUCHE : MOTEUR // DROITE : PROPULSEUR</div>
    </div>

    <div id="message-box">
        <h2 id="msg-title" style="margin-top:0; color:#0ff; text-shadow:0 0 10px #0ff;">CYBER BIBOU</h2>
        <p id="msg-text" style="font-family: sans-serif; line-height: 1.5;">Pr√™t √† pirater le syst√®me ?</p>
        <button id="msg-btn" onclick="nextAction()">LANCER</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * CYBER BIBOU 2077 v3.2
 * Bibou Fun Edition
 * Fix: Game Loop ID, Powerup Spawn Rate
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

// --- CONFIGURATION ---
const GRAVITY_DEFAULT = 0.55; 
let currentGravity = GRAVITY_DEFAULT;
const FRICTION = 0.85; 
const MAX_SPEED = 6; 
const JUMP_FORCE = -13; 
const TILE_SIZE = 50;

// --- ETATS DU JEU ---
let gameState = 'start'; 
let currentLevel = 1;
let coins = 0;
let lives = 3;
let cameraX = 0;

// SYSTEME DE SESSION (ANTI-BUG REBOOT)
// Chaque fois qu'on lance le jeu, on change d'ID.
// La boucle de jeu v√©rifie si elle est toujours la "bonne".
let gameSessionId = 0; 
let gameTime = 0; 

// Powerup state
let hasShield = false;
let magnetTimer = 0;

// --- DONNEES DES NIVEAUX ---
const LEVEL_CONFIG = {
    1: { 
        name: "SECTEUR ALPHA", 
        length: 50, gapProb: 0.1, spikeProb: 0.1, 
        color: '#00ffff', bgStart:'#050510', bgEnd:'#1a1a2e',
        hasCeiling: false, gravityMod: 1 
    },
    2: { 
        name: "DATA CAVE", 
        length: 60, gapProb: 0.15, spikeProb: 0.25, 
        color: '#ff00ff', bgStart:'#1a051a', bgEnd:'#2e1a2e',
        hasCeiling: true, gravityMod: 1 
    },
    3: { 
        name: "LUNE CYBER", 
        length: 80, gapProb: 0.3, spikeProb: 0.3, 
        color: '#ffff00', bgStart:'#1a1a05', bgEnd:'#2e2e1a',
        hasCeiling: false, gravityMod: 0.5 
    }
};

// --- ENTIT√âS ---
let platforms = [];
let spikes = [];
let enemies = [];
let collectibles = [];
let powerups = []; 
let particles = [];
let stars = [];
let cityBuildings = [];
let flag = null;
let trail = [];

const player = {
    x: 100, y: 100, w: 40, h: 60,
    vx: 0, vy: 0,
    grounded: false, facingRight: true,
    invincible: false,
    alpha: 1
};

// Inputs
let inputX = 0;
let touchStartX = 0;
let moveFingerId = null;

// --- INITIALISATION & GRAPHISMES ---

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    generateBackgroundElements();
}
window.addEventListener('resize', resize);

function generateBackgroundElements() {
    stars = [];
    for(let i=0; i<100; i++) {
        stars.push({
            x: Math.random() * width,
            y: Math.random() * height * 0.8,
            size: Math.random() * 2,
            alpha: Math.random()
        });
    }

    cityBuildings = [];
    let x = 0;
    while(x < width * 2) { 
        let w = 40 + Math.random() * 80;
        let h = 100 + Math.random() * 300;
        cityBuildings.push({x: x, w: w, h: h});
        x += w + 5; 
    }
}

function initLevel(levelNum) {
    platforms = [];
    spikes = [];
    collectibles = [];
    powerups = [];
    enemies = [];
    particles = [];
    trail = [];
    cameraX = 0; // Reset cam√©ra CRUCIAL
    
    respawnPlayer(true); // Force reset position
    
    // Reset Powerups
    magnetTimer = 0;
    hasShield = false;
    updatePowerupUI();

    const config = LEVEL_CONFIG[levelNum];
    currentGravity = GRAVITY_DEFAULT * config.gravityMod;
    const mainColor = config.color;

    // HUD
    document.getElementById('level-indicator').innerText = config.name;
    document.getElementById('level-indicator').style.color = mainColor;
    document.getElementById('level-indicator').style.textShadow = `0 0 10px ${mainColor}`;
    updateLivesDisplay();

    let cx = 0;
    let cy = height - TILE_SIZE * 3;

    // Start Platform
    platforms.push({x: -100, y: cy, w: 500, h: height, type: 'start'});
    cx += 400;

    for(let i=0; i < config.length; i++) {
        // Trous
        if(Math.random() < config.gapProb) {
            let gapSize = TILE_SIZE * (2 + Math.random() * (config.gravityMod < 1 ? 5 : 2));
            cx += gapSize;
        } 
        
        // Hauteur
        if (Math.random() < 0.4) {
            let hChange = (Math.floor(Math.random() * 3) - 1) * TILE_SIZE; 
            cy += hChange;
        }
        
        // Limites
        if(cy > height - TILE_SIZE * 2) cy = height - TILE_SIZE * 2;
        if(cy < height * 0.4) cy = height * 0.4;

        let platWidth = TILE_SIZE * (3 + Math.random() * 4);
        
        platforms.push({
            x: cx, y: cy, w: platWidth, h: height, 
            type: 'normal'
        });

        // Plafond (Plus haut pour niveau 2)
        if(config.hasCeiling) {
            platforms.push({
                x: cx, y: 0, w: platWidth, h: cy - 200 - (Math.random()*50), // + Haut (200 au lieu de 150)
                type: 'ceiling'
            });
        }

        // --- OBJETS ---

        let hasSomething = false;

        // Ennemis
        if(i > 2 && Math.random() < 0.2) { 
            enemies.push({
                x: cx + 20,
                y: cy - 30,
                w: 30, h: 30,
                xStart: cx,
                xEnd: cx + platWidth,
                speed: 1.5 + Math.random(), 
                dir: 1,
                color: '#ff3333'
            });
            hasSomething = true;
        }
        // Pics
        else if(Math.random() < config.spikeProb) {
            spikes.push({
                x: cx + platWidth/2 - 15,
                y: cy - 20, w: 30, h: 20
            });
            hasSomething = true;
        }

        // Collectibles
        if(Math.random() < 0.6) {
            collectibles.push({
                x: cx + platWidth/2,
                y: cy - 50 - (Math.random() * 80), 
                r: 10, active: true,
                offset: Math.random() * Math.PI,
                w: 20, h: 20
            });
        }

        // Power-ups (Beaucoup plus fr√©quents : 10% de chance + garantie pas sur un pic)
        // On n'en met pas s'il y a d√©j√† un pic ou un ennemi au m√™me endroit
        if(!hasSomething && Math.random() < 0.10) { 
            let type = Math.random() > 0.5 ? 'shield' : 'magnet';
            powerups.push({
                x: cx + platWidth/2,
                y: cy - 60,
                type: type, active: true,
                offset: Math.random() * Math.PI
            });
        }

        cx += platWidth;
    }

    cx += 100;
    platforms.push({x: cx, y: cy, w: 600, h: height, type: 'end'});
    flag = { x: cx + 300, y: cy - 100 };
}

function respawnPlayer(fullReset) {
    if(fullReset) {
        player.x = 100;
        player.y = 100;
        player.vx = 0; player.vy = 0;
    }
    player.invincible = true;
    player.alpha = 0.5;
    setTimeout(() => {
        player.invincible = false;
        player.alpha = 1;
    }, 2000);
}

// --- LOGIQUE GLOBALE (FIX BUG REBOOT VIA SESSION ID) ---

function nextAction() {
    const box = document.getElementById('message-box');
    
    // On incr√©mente l'ID de session. 
    // Si une ancienne boucle tourne, elle verra que son ID est p√©rim√© et s'arr√™tera.
    gameSessionId++; 
    const currentSession = gameSessionId;

    if(gameState === 'start' || gameState === 'gameover' || gameState === 'win') {
        currentLevel = 1;
        coins = 0;
        lives = 3;
        document.getElementById('score-board').innerText = "CREDITS: 0";
        gameState = 'playing';
        initLevel(currentLevel);
    } 
    else if (gameState === 'level_complete') {
        currentLevel++;
        if(currentLevel > 3) {
            winGame();
            return;
        }
        gameState = 'playing';
        initLevel(currentLevel);
    }
    
    box.style.display = 'none';
    
    // On lance la boucle avec l'ID de session actuel
    loop(currentSession);
}

function takeDamage(sourceX) {
    if(player.invincible) return;

    if(hasShield) {
        hasShield = false;
        updatePowerupUI();
        player.invincible = true;
        createParticles(player.x, player.y, 20, '#00ff00');
        player.vy = -5;
        player.vx = (player.x < sourceX) ? -6 : 6;
        setTimeout(() => { player.invincible = false; }, 1000);
        return;
    }

    lives--;
    updateLivesDisplay();
    createParticles(player.x, player.y, 30, '#ff0000');
    
    if(lives <= 0) {
        gameOver();
    } else {
        player.invincible = true;
        player.alpha = 0.5;
        player.vy = -7;
        player.vx = (player.x < sourceX) ? -8 : 8; 
        setTimeout(() => {
            player.invincible = false;
            player.alpha = 1;
        }, 1500);
    }
}

function updateLivesDisplay() {
    let hearts = "";
    for(let i=0; i<lives; i++) hearts += "‚ù§";
    document.getElementById('lives-display').innerText = hearts;
}

function updatePowerupUI() {
    document.getElementById('status-shield').style.display = hasShield ? 'block' : 'none';
    document.getElementById('status-magnet').style.display = magnetTimer > 0 ? 'block' : 'none';
}

function gameOver() {
    gameState = 'gameover';
    showModal("√âCHEC CRITIQUE", "Syst√®me corrompu.<br>Plus aucune vie disponible.", "#ff0000", "REBOOT");
}

function levelComplete() {
    gameState = 'level_complete';
    showModal("NIVEAU PIRAT√â", `S√©quence termin√©e.<br>Cr√©dits accumul√©s : ${coins}`, "#00ff00", "NIVEAU SUIVANT");
}

function winGame() {
    gameState = 'win';
    showModal("MISSION ACCOMPLIE", `L√©gende Cybern√©tique !<br>Score Final : ${coins} cr√©dits.`, "#ffff00", "NOUVELLE PARTIE");
}

function showModal(title, text, color, btnText) {
    const box = document.getElementById('message-box');
    const t = document.getElementById('msg-title');
    const txt = document.getElementById('msg-text');
    const btn = document.getElementById('msg-btn');
    
    t.innerText = title;
    t.style.color = color;
    t.style.textShadow = `0 0 15px ${color}`;
    
    txt.innerHTML = text;
    btn.innerText = btnText;
    btn.style.borderColor = color;
    btn.style.color = color;
    btn.style.boxShadow = `0 0 10px ${color}`;
    
    box.style.display = 'block';
}

// --- CONTROLES ---

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if(gameState !== 'playing') return; // Bloquer les inputs si pas en jeu
    for(let i=0; i<e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        if(t.clientX < width/2) {
            if(moveFingerId === null) {
                moveFingerId = t.identifier;
                touchStartX = t.clientX;
            }
        } else {
            if(player.grounded) {
                player.vy = JUMP_FORCE;
                player.grounded = false;
                createParticles(player.x + player.w/2, player.y + player.h, 10, '#fff');
            } else if (currentLevel === 3 && player.vy > 0) {
                 player.vy = -8;
                 createParticles(player.x, player.y + player.h, 5, '#ffff00');
            }
        }
    }
}, {passive: false});

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if(gameState !== 'playing') return;
    for(let i=0; i<e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        if(t.identifier === moveFingerId) {
            let delta = t.clientX - touchStartX;
            if(delta > 15) inputX = 1;
            else if(delta < -15) inputX = -1;
            else inputX = 0;
            if(Math.abs(delta) > 50) touchStartX = t.clientX - (50 * Math.sign(delta));
        }
    }
}, {passive: false});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        if(e.changedTouches[i].identifier === moveFingerId) {
            moveFingerId = null;
            inputX = 0;
        }
    }
});

window.addEventListener('keydown', (e) => {
    if(gameState !== 'playing') return;
    if(e.code === 'ArrowRight') inputX = 1;
    if(e.code === 'ArrowLeft') inputX = -1;
    if(e.code === 'Space') {
        if(player.grounded) {
            player.vy = JUMP_FORCE;
            player.grounded = false;
        } else if (currentLevel === 3 && player.vy > 0) {
             player.vy = -8;
        }
    }
});
window.addEventListener('keyup', (e) => inputX = 0);

// --- UPDATE ---

function update() {
    if(gameState !== 'playing') return;
    gameTime += 0.05;

    // Powerup Timers
    if(magnetTimer > 0) {
        magnetTimer--;
        if(magnetTimer <= 0) updatePowerupUI();
    }

    // Physique
    if(inputX !== 0) {
        player.vx += inputX * 0.5;
        player.facingRight = inputX > 0;
    } else {
        player.vx *= FRICTION;
    }
    
    if(player.vx > MAX_SPEED) player.vx = MAX_SPEED;
    if(player.vx < -MAX_SPEED) player.vx = -MAX_SPEED;

    player.vy += currentGravity;
    player.x += player.vx;
    player.y += player.vy;

    // Collisions Plateformes
    player.grounded = false;
    for(let p of platforms) {
        if(player.x < p.x + p.w && player.x + player.w > p.x &&
           player.y < p.y + p.h && player.y + player.h > p.y) {
            
            let prevY = player.y - player.vy;
            if(prevY + player.h <= p.y + 20 && player.vy >= 0) {
                player.y = p.y - player.h;
                player.vy = 0;
                player.grounded = true;
            }
            else if (prevY >= p.y + p.h - 20 && player.vy < 0) {
                player.y = p.y + p.h;
                player.vy = 0;
            }
            else if (player.x + player.w/2 < p.x + p.w/2) {
                 player.x = p.x - player.w;
                 player.vx = 0;
            } else {
                player.x = p.x + p.w;
                player.vx = 0;
            }
        }
    }

    if(player.y > height + 200) {
        lives = 0;
        updateLivesDisplay();
        gameOver();
    }

    // Pics
    for(let s of spikes) {
        if(checkRectCollide(player, s)) {
            takeDamage(s.x + s.w/2);
        }
    }

    // Ennemis
    for(let e of enemies) {
        e.x += e.speed * e.dir;
        if(e.x > e.xEnd || e.x < e.xStart) e.dir *= -1;
        
        if(checkRectCollide(player, e)) {
            takeDamage(e.x + e.w/2);
        }
    }

    // Collectibles
    for(let c of collectibles) {
        if(c.active) {
            if(magnetTimer > 0) {
                let dist = Math.sqrt(Math.pow(player.x - c.x, 2) + Math.pow(player.y - c.y, 2));
                if(dist < 300) {
                    c.x += (player.x + player.w/2 - c.x) * 0.15;
                    c.y += (player.y + player.h/2 - c.y) * 0.15;
                }
            }

            let cBox = {x: c.x - c.w/2, y: c.y - c.h/2, w: c.w, h: c.h};
            if (checkRectCollide(player, cBox)) {
                c.active = false;
                coins++;
                document.getElementById('score-board').innerText = `CREDITS: ${coins}`;
                createParticles(c.x, c.y, 10, LEVEL_CONFIG[currentLevel].color);
            }
        }
    }

    // Powerups
    for(let p of powerups) {
        if(p.active) {
            let pBox = {x: p.x - 15, y: p.y - 15, w: 30, h: 30};
             if (checkRectCollide(player, pBox)) {
                p.active = false;
                if(p.type === 'shield') hasShield = true;
                if(p.type === 'magnet') magnetTimer = 400;
                updatePowerupUI();
                createParticles(p.x, p.y, 20, p.type === 'shield' ? '#00ff00' : '#aa00ff');
            }
        }
    }

    // Drapeau
    if(player.x < flag.x + 50 && player.x + player.w > flag.x &&
       player.y < flag.y + 100 && player.y + player.h > flag.y) {
        levelComplete();
    }

    // Cam√©ra
    let targetCam = player.x - width * 0.3;
    if(targetCam < 0) targetCam = 0;
    cameraX += (targetCam - cameraX) * 0.1;

    // Particules
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy;
        p.life--; p.alpha -= 0.03;
        if(p.life <= 0) particles.splice(i,1);
    }
}

function checkRectCollide(r1, r2) {
    return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x &&
            r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
}

// --- RENDU (DRAW) ---

function draw() {
    let config = LEVEL_CONFIG[currentLevel];
    let lvlColor = config.color;
    
    let grad = ctx.createLinearGradient(0, 0, 0, height);
    grad.addColorStop(0, config.bgStart);
    grad.addColorStop(1, config.bgEnd);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, width, height);

    ctx.fillStyle = '#fff';
    for(let s of stars) {
        let sx = (s.x - cameraX * 0.05) % width;
        if(sx < 0) sx += width;
        ctx.globalAlpha = s.alpha;
        ctx.fillRect(sx, s.y, s.size, s.size);
    }
    ctx.globalAlpha = 1;

    let cityParallax = cameraX * 0.2;
    let cityOffset = -(cityParallax % width);
    drawCityLayer(cityOffset, lvlColor);
    drawCityLayer(cityOffset + width, lvlColor);

    ctx.save();
    ctx.translate(-cameraX, 0);

    ctx.shadowBlur = 10;
    ctx.shadowColor = lvlColor;
    ctx.strokeStyle = lvlColor;
    ctx.lineWidth = 3;
    ctx.fillStyle = '#000';

    for(let p of platforms) {
        if(p.x + p.w > cameraX && p.x < cameraX + width) {
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.strokeRect(p.x, p.y, p.w, p.h);
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1; ctx.shadowBlur = 0;
            for(let gx=p.x; gx<p.x+p.w; gx+=25) { ctx.moveTo(gx, p.y); ctx.lineTo(gx, p.y + p.h); }
            ctx.stroke();
            ctx.restore();
        }
    }

    ctx.fillStyle = '#ff0055'; 
    ctx.shadowColor = '#ff0055';
    for(let s of spikes) {
        if(s.x + s.w > cameraX && s.x < cameraX + width) {
            ctx.beginPath();
            ctx.moveTo(s.x, s.y + s.h);
            ctx.lineTo(s.x + s.w/2, s.y);
            ctx.lineTo(s.x + s.w, s.y + s.h);
            ctx.fill();
        }
    }

    for(let e of enemies) {
        if(e.x + e.w > cameraX && e.x < cameraX + width) {
            let floatY = Math.abs(Math.sin(gameTime * e.speed)) * 5;
            
            ctx.shadowBlur = 10;
            ctx.shadowColor = e.color;
            ctx.fillStyle = e.color;
            
            ctx.beginPath();
            ctx.arc(e.x + e.w/2, e.y + e.h - floatY, e.w/2, Math.PI, 0);
            ctx.lineTo(e.x + e.w, e.y + e.h);
            ctx.lineTo(e.x, e.y + e.h);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.fillRect(e.x + 5, e.y + 10 - floatY, 8, 8);
            ctx.fillRect(e.x + 18, e.y + 10 - floatY, 8, 8);
        }
    }

    ctx.shadowBlur = 15;
    ctx.shadowColor = '#ffd700';
    for(let c of collectibles) {
        if(c.active && c.x + c.r > cameraX && c.x - c.r < cameraX + width) {
            let floatY = Math.sin(gameTime + c.offset) * 8;
            drawHexagon(c.x, c.y + floatY, c.r, '#ffd700');
        }
    }

    for(let p of powerups) {
        if(p.active && p.x > cameraX && p.x < cameraX + width) {
            let floatY = Math.sin(gameTime + p.offset * 2) * 5;
            let color = p.type === 'shield' ? '#00ff00' : '#aa00ff';
            ctx.shadowColor = color; ctx.shadowBlur = 20; ctx.fillStyle = color;
            ctx.beginPath(); ctx.arc(p.x, p.y + floatY, 15, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(p.type === 'shield' ? 'S' : 'M', p.x, p.y + floatY);
        }
    }

    ctx.shadowColor = lvlColor;
    ctx.fillStyle = '#fff';
    ctx.fillRect(flag.x, flag.y, 4, 100); 
    ctx.fillStyle = `rgba(${lvlColor === '#00ffff' ? '0,255,255' : (lvlColor === '#ff00ff' ? '255,0,255' : '255,255,0')}, 0.5)`;
    ctx.beginPath();
    ctx.moveTo(flag.x + 4, flag.y + 10);
    ctx.lineTo(flag.x + 80, flag.y + 30 + Math.sin(gameTime)*5);
    ctx.lineTo(flag.x + 4, flag.y + 60);
    ctx.fill();

    for(let p of particles) {
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 4, 4);
    }
    ctx.globalAlpha = 1;

    if(player.invincible) {
        ctx.globalAlpha = 0.5 + Math.sin(gameTime * 20) * 0.3;
    }
    drawCyberBibou(lvlColor);
    ctx.globalAlpha = 1;

    ctx.restore();
}

function drawCityLayer(offsetX, color) {
    ctx.fillStyle = '#101015'; 
    for(let b of cityBuildings) {
        let drawX = b.x + offsetX;
        if(drawX > -100 && drawX < width) {
            ctx.fillRect(drawX, height - b.h, b.w, b.h);
            ctx.fillStyle = color; ctx.globalAlpha = 0.3;
            if(b.w > 20) {
                for(let wy = height - b.h + 10; wy < height; wy += 40) {
                    if((b.x + wy) % 7 === 0) ctx.fillRect(drawX + 10, wy, b.w - 20, 5);
                }
            }
            ctx.globalAlpha = 1; ctx.fillStyle = '#101015';
        }
    }
}

function drawHexagon(x, y, r, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        ctx.lineTo(x + r * Math.cos(i * 2 * Math.PI / 6), y + r * Math.sin(i * 2 * Math.PI / 6));
    }
    ctx.closePath();
    ctx.fill();
}

function drawCyberBibou(glowColor) {
    let px = player.x;
    let py = player.y;
    let pw = player.w;
    let ph = player.h;

    let legCycle = 0;
    if(Math.abs(player.vx) > 0.5 && !player.grounded) legCycle = 0.5;
    else if(Math.abs(player.vx) > 0.5) legCycle = Math.sin(gameTime * 2);

    ctx.save();
    ctx.translate(px + pw/2, py + ph/2);
    if (!player.facingRight) ctx.scale(-1, 1);

    if(hasShield) {
        ctx.beginPath(); ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2;
        ctx.arc(0, 0, 45, 0, Math.PI*2); ctx.stroke();
        ctx.fillStyle = 'rgba(0, 255, 0, 0.15)'; ctx.fill();
    }

    ctx.shadowBlur = 10; ctx.shadowColor = '#e74c3c';
    
    ctx.fillStyle = '#e74c3c';
    ctx.fillRect(-15, -20, 30, 40);
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.moveTo(-10, -20); ctx.lineTo(10, -20); ctx.lineTo(0, 5); ctx.fill();
    ctx.fillStyle = '#2c3e50';
    ctx.beginPath(); ctx.arc(0, -30, 16, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#0ff'; ctx.fillRect(5, -34, 10, 6);

    if(Math.abs(player.vx) > 1 || currentGravity < GRAVITY_DEFAULT) {
        ctx.fillStyle = glowColor;
        ctx.beginPath(); ctx.moveTo(-18, 5); ctx.lineTo(-25, 15); ctx.lineTo(-14, 15); ctx.fill();
        if(currentGravity < GRAVITY_DEFAULT && player.vy < 0) {
             ctx.fillStyle = '#ffaa00';
             ctx.beginPath(); ctx.moveTo(-18, 15); ctx.lineTo(-20, 25); ctx.lineTo(-16, 25); ctx.fill();
        }
    }

    ctx.strokeStyle = '#fff'; ctx.lineWidth = 6; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(-5, 20); ctx.lineTo(-5 - Math.sin(legCycle)*15, 35); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(10, 20); ctx.lineTo(10 + Math.sin(legCycle)*15, 35); ctx.stroke();
    
    ctx.strokeStyle = '#e74c3c';
    ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(15, 5 + Math.cos(legCycle)*10); ctx.stroke();

    ctx.restore();
}

function createParticles(x, y, count, color) {
    for(let i=0; i<count; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            life: 20 + Math.random() * 10,
            alpha: 1, color: color
        });
    }
}

// Fonction de boucle critique qui v√©rifie l'ID de session
function loop(sessionId) {
    // S√©curit√©: si cette boucle appartient √† une vieille session, on l'arr√™te.
    if(sessionId !== gameSessionId) return;

    update();
    draw();
    requestAnimationFrame(() => loop(sessionId));
}

resize();
generateBackgroundElements();
document.getElementById('message-box').style.display = 'block';

</script>
</body>
</html>


