<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#2c3e50">
    <title>Super Bibou Run</title>
    
    <!-- Configuration PWA : Force le mode Paysage sur mobile -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="BibouRun">
    <!-- Manifest avec orientation paysage -->
    <link rel="manifest" href="data:application/manifest+json;base64,ewogICJuYW1lIjogIlN1cGVyIEJpYm91IFJ1biIsCiAgInNob3J0X25hbWUiOiAiQmlib3VSdW4iLAogICJzdGFydF91cmwiOiAiLiIsCiAgImRpc3BsYXkiOiAiZnVsbHNjcmVlbiIsCiAgIm9yaWVudGF0aW9uIjogImxhbmRzY2FwZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzJjM2U1MCIiwKICAidGhlbWVfY29sb3IiOiAiIzJjM2U1MCIKfQ==">
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #87CEEB;
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }
        #score-board {
            font-size: 24px;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            pointer-events: auto;
            border: 3px solid #e74c3c;
            z-index: 20;
            min-width: 300px;
        }
        button {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            border-radius: 8px;
            margin-top: 20px;
            cursor: pointer;
            font-weight: bold;
        }
        button:active {
            background: #c0392b;
        }
        #controls-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.8);
            font-size: 16px;
            pointer-events: none;
            text-shadow: 1px 1px 0 #000;
        }

        /* √âcran pour forcer la rotation */
        #rotate-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #2c3e50;
            z-index: 9999;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-align: center;
        }
        /* D√©tection Portrait via CSS */
        @media screen and (orientation: portrait) {
            #rotate-screen { display: flex; }
        }
    </style>
</head>
<body>

    <!-- √âcran de rotation forc√© -->
    <div id="rotate-screen">
        <div style="font-size: 50px;">üîÑ</div>
        <h2>Tourne ton t√©l√©phone !</h2>
        <p>Ce jeu se joue en mode paysage<br>pour mieux voir les pi√®ges !</p>
    </div>

    <div id="ui-layer">
        <div id="score-board">Pi√®ces: 0 | Vies: 3</div>
        <div id="controls-hint">üëà Pouce gauche: Bouger &nbsp;&nbsp;&nbsp; üëâ Pouce droit: Sauter</div>
    </div>

    <div id="message-box">
        <h2 id="msg-title" style="margin-top:0;">Titre</h2>
        <p id="msg-text">Texte</p>
        <button onclick="startGame()">C'est parti !</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * SUPER BIBOU RUN 2.0
 * Avec parallax, d√©cors et perso agrandi
 */

// --- Configuration ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

// √âtats du jeu
let gameState = 'start'; // start, playing, gameover, win
let coins = 0;
let lives = 3;
let cameraX = 0;
let animationFrameId;

// Physique
const GRAVITY = 0.6;
const FRICTION = 0.85;
const MOVE_SPEED = 0.6; 
const MAX_SPEED = 7;
const JUMP_FORCE = -14; // Saut un peu plus puissant pour compenser la taille

// Inputs
let touchStartX = 0;
let isTouchingMove = false;
let moveFingerId = null;
let inputX = 0; 

// Le Monde
const TILE_SIZE = 50;
const LEVEL_LENGTH = 180; // Un peu plus long
let platforms = [];
let spikes = [];
let collectibles = [];
let clouds = [];
let mountains = [];
let flag = null;
let particles = [];

// Le Joueur (Plus grand !)
const player = {
    x: 100,
    y: 100,
    w: 45, // Plus large (avant 30)
    h: 75, // Plus haut (avant 50)
    vx: 0,
    vy: 0,
    grounded: false,
    facingRight: true,
    animTimer: 0
};

// --- Initialisation ---

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    // Si on redimensionne, on r√©g√©n√®re le d√©cor de fond pour qu'il s'adapte
    if(mountains.length === 0) initBackgrounds();
}
window.addEventListener('resize', resize);
resize();

function initBackgrounds() {
    clouds = [];
    mountains = [];
    
    // G√©n√©rer des nuages
    for(let i=0; i<20; i++) {
        clouds.push({
            x: Math.random() * (LEVEL_LENGTH * TILE_SIZE),
            y: Math.random() * (height / 2),
            w: 60 + Math.random() * 80,
            speed: 0.2 + Math.random() * 0.3
        });
    }

    // G√©n√©rer des montagnes (d√©cor de fond)
    let mX = 0;
    while(mX < LEVEL_LENGTH * TILE_SIZE) {
        let mW = 300 + Math.random() * 500;
        let mH = 200 + Math.random() * 300;
        mountains.push({
            x: mX,
            y: height, // Base de la montagne en bas de l'√©cran
            w: mW,
            h: mH,
            color: Math.random() > 0.5 ? '#5D6D7E' : '#34495E' // Gris bleut√©
        });
        mX += mW - 100; // Chevauchement
    }
}

function initLevel() {
    platforms = [];
    spikes = [];
    collectibles = [];
    particles = [];
    initBackgrounds(); // Reset backgrounds
    
    // Sol de d√©part safe
    for(let i=0; i<15; i++) {
        platforms.push({x: i*TILE_SIZE, y: height - TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE});
    }

    // G√©n√©ration proc√©durale du niveau
    let currentX = 15 * TILE_SIZE;
    let currentY = height - TILE_SIZE;

    for(let i=15; i < LEVEL_LENGTH; i++) {
        let rand = Math.random();
        
        if (rand < 0.15) {
            // Trou
            currentX += TILE_SIZE * 1.5; // Trou un peu plus large parfois
        } else if (rand < 0.35) {
            // Changement de hauteur
            let heightChange = (Math.floor(Math.random() * 3) - 1) * TILE_SIZE;
            currentY += heightChange;
            // Limites bas/haut
            if(currentY > height - TILE_SIZE) currentY = height - TILE_SIZE;
            if(currentY < height - 300) currentY = height - 300;
            
            platforms.push({x: currentX, y: currentY, w: TILE_SIZE, h: TILE_SIZE});
            
            // Pic ?
            if(Math.random() < 0.3) {
                spikes.push({x: currentX + 10, y: currentY - 20, w: 30, h: 20});
            }
             currentX += TILE_SIZE;
        } else {
            // Sol normal
            platforms.push({x: currentX, y: currentY, w: TILE_SIZE, h: TILE_SIZE});
            
            // Pi√®ce ?
            if(Math.random() < 0.25) {
                // Pi√®ce plac√©e un peu plus bas pour √™tre attrapable debout
                collectibles.push({
                    x: currentX + TILE_SIZE/2, 
                    y: currentY - 50, // Plus proche du sol
                    r: 12, // Pi√®ce plus grosse
                    active: true,
                    floatOffset: Math.random() * Math.PI
                });
            }
            currentX += TILE_SIZE;
        }
    }

    // Arriv√©e
    flag = { x: currentX, y: currentY - 120 };
    platforms.push({x: currentX, y: currentY, w: TILE_SIZE*5, h: TILE_SIZE});
}

function showStartScreen() {
    const box = document.getElementById('message-box');
    document.getElementById('msg-title').innerText = "Super Bibou Run";
    document.getElementById('msg-title').style.color = "#3498db";
    document.getElementById('msg-text').innerHTML = "Bibou doit rejoindre le drapeau !<br>√âvite les pics rouges.<br><br><i>Tourne ton √©cran en paysage !</i>";
    box.style.display = 'block';
}

function startGame() {
    gameState = 'playing';
    player.x = 100;
    player.y = 100;
    player.vx = 0;
    player.vy = 0;
    cameraX = 0;
    lives = 3;
    coins = 0;
    document.getElementById('message-box').style.display = 'none';
    initLevel();
    updateUI();
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    loop();
}

// --- Gestion des Contr√¥les Tactiles ---
// Zone gauche de l'√©cran = Mouvement
// Zone droite de l'√©cran (ou tap n'importe o√π ailleurs) = Saut

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        
        // Si le touch est dans la moiti√© gauche de l'√©cran, c'est pour bouger
        if (t.clientX < window.innerWidth / 2) {
            if (!isTouchingMove) {
                isTouchingMove = true;
                moveFingerId = t.identifier;
                touchStartX = t.clientX;
            }
        } else {
            // Sinon (moiti√© droite), c'est un saut
            if (player.grounded) {
                player.vy = JUMP_FORCE;
                player.grounded = false;
                createParticles(player.x + player.w/2, player.y + player.h, 5, '#fff');
            }
        }
    }
}, {passive: false});

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        if (t.identifier === moveFingerId) {
            let delta = t.clientX - touchStartX;
            if (delta > 10) inputX = 1;
            else if (delta < -10) inputX = -1;
            else inputX = 0;
            
            // Reset l'origine si on va trop loin, pour le confort
            if (Math.abs(delta) > 60) {
               touchStartX = t.clientX - (60 * Math.sign(delta));
            }
        }
    }
}, {passive: false});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        let t = e.changedTouches[i];
        if (t.identifier === moveFingerId) {
            isTouchingMove = false;
            moveFingerId = null;
            inputX = 0;
        }
    }
});

// Clavier PC (pour d√©bugger)
window.addEventListener('keydown', (e) => {
    if(e.code === 'ArrowRight') inputX = 1;
    if(e.code === 'ArrowLeft') inputX = -1;
    if(e.code === 'Space' && player.grounded) {
        player.vy = JUMP_FORCE;
        player.grounded = false;
    }
});
window.addEventListener('keyup', (e) => {
    if(e.code === 'ArrowRight' || e.code === 'ArrowLeft') inputX = 0;
});

// --- Moteur de Jeu ---

function update() {
    if (gameState !== 'playing') return;

    // Physique Joueur
    if (inputX !== 0) {
        player.vx += inputX * MOVE_SPEED;
        player.facingRight = inputX > 0;
        player.animTimer += 0.2;
    } else {
        player.vx *= FRICTION;
        player.animTimer = 0;
    }

    // Clamp vitesse
    if (player.vx > MAX_SPEED) player.vx = MAX_SPEED;
    if (player.vx < -MAX_SPEED) player.vx = -MAX_SPEED;

    player.vy += GRAVITY;
    player.x += player.vx;
    player.y += player.vy;

    // Collisions Plateformes
    player.grounded = false;
    for (let p of platforms) {
        // Optimisation collision : ne v√©rifier que les plateformes proches
        if (p.x > player.x - 100 && p.x < player.x + 100) {
            if (checkRectCollide(player.x, player.y, player.w, player.h, p.x, p.y, p.w, p.h)) {
                // Bas
                if (player.vy > 0 && player.y + player.h - player.vy <= p.y + 10) { // +10 tol√©rance
                    player.y = p.y - player.h;
                    player.vy = 0;
                    player.grounded = true;
                }
                // Haut
                else if (player.vy < 0 && player.y - player.vy >= p.y + p.h) {
                    player.y = p.y + p.h;
                    player.vy = 0;
                }
                // Cot√©s
                else if (player.vx > 0 && player.x + player.w - player.vx <= p.x) {
                    player.x = p.x - player.w;
                    player.vx = 0;
                }
                else if (player.vx < 0 && player.x - player.vx >= p.x + p.w) {
                    player.x = p.x + p.w;
                    player.vx = 0;
                }
            }
        }
    }

    // Collisions Pics
    for (let s of spikes) {
        if (s.x > player.x - 100 && s.x < player.x + 100) {
            // Hitbox un peu plus petite pour le joueur vs pics (plus gentil)
            if (checkRectCollide(player.x + 5, player.y + 5, player.w - 10, player.h - 10, s.x, s.y, s.w, s.h)) {
                hurtPlayer();
            }
        }
    }

    // Collisions Pi√®ces
    for (let c of collectibles) {
        if (c.active && c.x > player.x - 100 && c.x < player.x + 100) {
            if(checkRectCollide(player.x, player.y, player.w, player.h, c.x - c.r, c.y - c.r, c.r*2, c.r*2)) {
                c.active = false;
                coins++;
                updateUI();
                createParticles(c.x, c.y, 8, '#f1c40f');
            }
            c.floatOffset += 0.1;
        }
    }

    // Nuages (D√©filement continu)
    for(let c of clouds) {
        c.x -= c.speed;
        // Si le nuage sort √† gauche (loin), on le remet loin √† droite
        // On calcule par rapport √† la cam√©ra pour le recyclage
        if(c.x + c.w < cameraX - width) {
            c.x = cameraX + width + Math.random() * 500;
            c.y = Math.random() * (height / 2);
        }
    }

    // Victoire
    if (player.x > flag.x) {
        endGame(true);
    }

    // Mort chute
    if (player.y > height + 200) {
        hurtPlayer();
    }

    // Cam√©ra (Lerp pour fluidit√©)
    let targetCamX = player.x - width * 0.3;
    if (targetCamX < 0) targetCamX = 0;
    cameraX += (targetCamX - cameraX) * 0.1;

    // Particules
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if(p.life <= 0) particles.splice(i, 1);
    }
}

function hurtPlayer() {
    lives--;
    updateUI();
    createParticles(player.x + player.w/2, player.y + player.h/2, 30, '#e74c3c');
    
    if (lives <= 0) {
        endGame(false);
    } else {
        // Respawn
        player.y = 0; 
        player.x -= 250;
        if(player.x < 100) player.x = 100;
        player.vx = 0;
        player.vy = 0;
    }
}

function endGame(win) {
    gameState = win ? 'win' : 'gameover';
    const box = document.getElementById('message-box');
    const title = document.getElementById('msg-title');
    const txt = document.getElementById('msg-text');
    
    box.style.display = 'block';
    if (win) {
        title.innerText = "VICTOIRE !";
        title.style.color = "#2ecc71";
        txt.innerHTML = `Bravo Tintin !<br>Tu as rafl√© ${coins} pi√®ces !<br>Pr√™t pour l'ap√©ro ?`;
    } else {
        title.innerText = "A√Øe !";
        title.style.color = "#e74c3c";
        txt.innerHTML = "Pas grave, m√™me le LHC<br>a des jours sans.<br>R√©essaie !";
    }
}

function createParticles(x, y, count, color) {
    for(let i=0; i<count; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 12,
            vy: (Math.random() - 0.5) * 12,
            life: 20 + Math.random() * 20,
            color: color
        });
    }
}

function updateUI() {
    document.getElementById('score-board').innerHTML = `Pi√®ces: ${coins} | Vies: ${lives}`;
}

// --- Rendu ---

function draw() {
    // Ciel
    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, width, height);

    ctx.save();
    ctx.translate(-cameraX, 0);

    // 1. DESSIN ARRI√àRE PLAN (Parallax)
    
    // Soleil
    ctx.fillStyle = '#F1C40F';
    ctx.beginPath();
    ctx.arc(cameraX + width - 150, 120, 60, 0, Math.PI*2);
    ctx.fill();

    // Nuages (bougent doucement)
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    for(let c of clouds) {
        // On ne dessine que si visible (+marge)
        if(c.x + c.w > cameraX && c.x < cameraX + width) {
            drawCloud(c.x, c.y, c.w);
        }
    }

    // Montagnes (Parallax: on divise cameraX par 2 pour qu'elles bougent moins vite)
    ctx.save();
    // On annule le translate normal, et on en applique un plus lent
    ctx.translate(cameraX, 0); 
    ctx.translate(-cameraX * 0.2, 0); // Vitesse 20%
    
    for(let m of mountains) {
        // On doit v√©rifier la visibilit√© en tenant compte du parallax... un peu compliquer, 
        // on dessine tout ce qui est proche c'est plus simple pour ce code.
        let parallaxX = m.x; 
        // Check simple de visibilit√© relative
        if(parallaxX + m.w > cameraX * 0.8 - 500 && parallaxX < cameraX * 0.8 + width + 500) {
            ctx.fillStyle = m.color;
            ctx.beginPath();
            ctx.moveTo(m.x, m.y);
            ctx.lineTo(m.x + m.w/2, m.y - m.h);
            ctx.lineTo(m.x + m.w, m.y);
            ctx.fill();
            
            // Sommet enneig√©
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(m.x + m.w/2, m.y - m.h);
            ctx.lineTo(m.x + m.w/2 - 40, m.y - m.h + 80);
            ctx.lineTo(m.x + m.w/2 + 40, m.y - m.h + 80);
            ctx.fill();
            ctx.fillStyle = m.color;
        }
    }
    ctx.restore();

    // 2. DESSIN PREMIER PLAN (Jeu)

    // Plateformes
    ctx.fillStyle = '#27ae60'; 
    ctx.strokeStyle = '#2c3e50';
    ctx.lineWidth = 2;
    for (let p of platforms) {
        if(p.x + p.w > cameraX && p.x < cameraX + width) {
            // Bloc terre
            ctx.fillStyle = '#5D4037'; // Marron terre
            ctx.fillRect(p.x, p.y, p.w, p.h);
            
            // Herbe dessus
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(p.x, p.y, p.w, 15);
            
            // Contour
            ctx.strokeRect(p.x, p.y, p.w, p.h);
        }
    }

    // Pics
    ctx.fillStyle = '#c0392b';
    for (let s of spikes) {
        if(s.x + s.w > cameraX && s.x < cameraX + width) {
            ctx.beginPath();
            ctx.moveTo(s.x, s.y + s.h);
            ctx.lineTo(s.x + s.w/2, s.y);
            ctx.lineTo(s.x + s.w, s.y + s.h);
            ctx.fill();
            ctx.stroke();
        }
    }

    // Pi√®ces
    for (let c of collectibles) {
        if(c.active && c.x + c.r > cameraX && c.x - c.r < cameraX + width) {
            let floatY = Math.sin(c.floatOffset) * 5;
            // Ext√©rieur or
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(c.x, c.y + floatY, c.r, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
            // Int√©rieur brillant
            ctx.fillStyle = '#f39c12';
            ctx.beginPath();
            ctx.arc(c.x, c.y + floatY, c.r * 0.6, 0, Math.PI*2);
            ctx.fill();
            // Reflet blanc
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(c.x - c.r*0.3, c.y + floatY - c.r*0.3, 3, 0, Math.PI*2);
            ctx.fill();
        }
    }

    // Drapeau
    ctx.fillStyle = '#95a5a6'; // Mat gris
    ctx.fillRect(flag.x, flag.y, 8, 120);
    // Drapeau Rouge LHC
    ctx.fillStyle = '#e74c3c'; 
    ctx.beginPath();
    ctx.moveTo(flag.x + 8, flag.y + 10);
    ctx.lineTo(flag.x + 80, flag.y + 35);
    ctx.lineTo(flag.x + 8, flag.y + 60);
    ctx.fill();
    // Lion blanc (abstrait)
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(flag.x + 30, flag.y + 35, 10, 0, Math.PI*2);
    ctx.fill();


    // Particules
    for (let p of particles) {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 5, 5);
    }

    // --- Dessin du Joueur (Super Bibou v2) ---
    drawPlayer();

    ctx.restore();
}

function drawCloud(x, y, w) {
    ctx.beginPath();
    ctx.arc(x, y, 30, 0, Math.PI * 2);
    ctx.arc(x + 25, y - 20, 35, 0, Math.PI * 2);
    ctx.arc(x + 55, y, 30, 0, Math.PI * 2);
    ctx.fill();
}

function drawPlayer() {
    let px = player.x;
    let py = player.y;
    let pw = player.w;
    let ph = player.h;

    // Calcul animation marche
    let legOffset = 0;
    let armOffset = 0;
    if (Math.abs(player.vx) > 0.1 && !player.grounded) {
        legOffset = Math.PI / 3; // Jambes √©cart√©es saut
    } else if (Math.abs(player.vx) > 0.1) {
        legOffset = Math.sin(player.animTimer) * 0.8;
        armOffset = Math.cos(player.animTimer) * 0.8;
    }

    ctx.save();
    ctx.translate(px + pw/2, py + ph/2);
    if (!player.facingRight) ctx.scale(-1, 1);

    // Corps (Plus costaud)
    ctx.fillStyle = '#e74c3c'; // Chandail Rouge LHC
    ctx.fillRect(-15, -20, 30, 45);
    
    // Logo sur le torse (LHC style)
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(0, -5, 8, 0, Math.PI*2);
    ctx.fill();

    // T√™te
    ctx.fillStyle = '#f1c40f'; // Peau
    ctx.beginPath();
    ctx.arc(0, -30, 18, 0, Math.PI*2); // T√™te plus grosse
    ctx.fill();
    
    // Casquette
    ctx.fillStyle = '#2c3e50'; // Casquette bleue fonc√©e
    ctx.fillRect(-18, -42, 36, 10);
    ctx.fillRect(0, -42, 28, 10); // Visi√®re

    // Yeux
    ctx.fillStyle = 'black';
    ctx.fillRect(6, -34, 4, 4);

    // Jambes (Plus longues)
    ctx.strokeStyle = '#2c3e50'; // Pantalon noir
    ctx.lineWidth = 8; // Jambes plus √©paisses
    ctx.lineCap = 'round';
    
    ctx.beginPath();
    ctx.moveTo(-8, 20);
    ctx.lineTo(-8 - Math.sin(legOffset)*15, 38);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(8, 20);
    ctx.lineTo(8 + Math.sin(legOffset)*15, 38);
    ctx.stroke();

    // Bras
    ctx.strokeStyle = '#e74c3c'; // Manches rouges
    ctx.beginPath();
    ctx.moveTo(0, -10);
    ctx.lineTo(Math.sin(armOffset)*15, 10);
    ctx.stroke();

    // Cape (Bibou Style)
    ctx.fillStyle = 'white';
    ctx.fillRect(-12, -18, 20, 5); // Noeud
    // La cape qui vole
    if (Math.abs(player.vx) > 1) {
        ctx.fillStyle = 'rgba(236, 240, 241, 0.8)';
        ctx.beginPath();
        ctx.moveTo(-10, -15);
        ctx.lineTo(-40, -5);
        ctx.lineTo(-40, 25);
        ctx.lineTo(-10, 15);
        ctx.fill();
    }

    ctx.restore();
}

function checkRectCollide(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
}

function loop() {
    update();
    draw();
    animationFrameId = requestAnimationFrame(loop);
}

// Premier d√©marrage
showStartScreen();

</script>
</body>
</html>


